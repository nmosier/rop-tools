/* call.gds
 * Nicholas Mosier 2019
 */

/* NOTES
 * 1. Need to preserve SP (rbp) on pseudostack
 * 2. Arguments will already have been pushed onto the stack.
 * 3. This pseudo-op should NOT accept calls to libc functions. Those ought to
 *    be treated similar to BCALLs.
 */

/* CALLER RECORD
 * 0...	  (args)
 * 1	  return address (rsp)
 *
 * CALLEE RECORD
 * 0	  caller's SP (rbp)
 */


// calls function
CALL imm64 :=
     PUSH $ + 240 ; return address (rsp); (28+2)*8=
     JMP imm64 ; length = 2

// return from function
RET :=
    MOV rcx,rax ; preserve ACC
    MOV rax,rbp
    MOV rdx,rax
    ADD rax,8
    MOV r9,rax  ; preserve new SP
    MOV rax,[rdx]
    MOV rbp,r9  ; restore new SP
    MOV rdx,rax
    MOV rax,rcx ; restore ACC
    MOV rsp,rdx ; jump to new PC


// note that syscalls don't use the stack
// all arguments must be on the stack
// this pseudo-op loads them into rdi, rsi, and rdx
SYSCALL3 :=
  MOV rcx,rax   ; preserve ACC
  MOV rax,rbp   ; destroys rbx,rdx,r9,r12,r13,r14
  ADD rax,8     ; index of arg2
  MOV rax,[rax] ; load arg2
  MOV rsi,rax   ; destroys rdi / arg2 in place
  MOV rax,rbp   ; destroys rbx,rdx,r9,r12,r13,r14
  ADD rax,8     ; destroys rdi / index of arg3
  MOV r9,rax    ; destroys r12,r13,r14
  ADD rax,-8    ; destroys rdi / index of arg1
  MOV rax,[rax] ; load arg1
  MOV rdx,rax   ;
  MOV rdi,rdx   ; destroys rax / arg1,arg2 in place
  MOV rax,r9    ; destroys r14
  MOV rdx,rax   ; arg1,arg2,arg3 in place
  MOV rax,rcx   ; restore ACC (which is the syscall number)
  ret &0x11724b ; perform syscall

// destroys rdi
MOV rsi,rax :=
  MOV rsi,0
  MOV rdi, $ - 24 + 32 ; rdi = addr of placeholder garbage
  ret &0x12fb52 + 6
  MOV rdi,0x1234 ; placeholder for preceding gadget

#
